.pos 0
Init:
    irmovl Stack, %rbp
    irmovl Stack, %rsp
    jmp Main

.pos 0x100
Stack:

.pos 0x104

# __fastcall int Multiply (int x, int y)
# x is passed in as %rcx, y is passed in as %rdx.
Multiply:
    # Set up stack frame.
    pushl %rbp
    rrmovl %rsp, %rbp
    pushl %rsi
    
    irmovl $-1, %rsi  # rsi = -1
    xorl %rax, %rax   # rax = 0

    # Skip multiply loop silently if multiplying by <= 0.
    andl %rdx, %rdx
    jle Multiply_End

Multiply_Loop:
    addl %rcx, %rax   # rax += rcx
    addl %rsi, %rdx   # rdx -= 1
    jne Multiply_Loop # if (rdx != 0) goto Multiply_Loop

Multiply_End:
    # Clean up stack frame.
    popl %rsi
    rrmovl %rbp, %rsp
    popl %rbp
    ret

# _cdecl int pow (int base, int exp)
Pow:
    # Set up stack frame.
    pushl %rbp
    rrmovl %rsp, %rbp
    
    irmovl $-1, %rsi      # rsi = -1
    
    # We'll use %rsi to demonstrate callee-save in Multiply,
    # since Multiply uses the callee-save %rsi register.
    mrmovl 8(%rbp), %rcx  # rcx = base
    mrmovl 12(%rbp), %rdi # rdi = exp
    
    rrmovl %rcx, %rdx     # rdx = base
    addl %rsi, %rdi       # rdi -= 1

Pow_Loop:
    pushl %rdx
    call Multiply         # rax = rcx * edx
    popl %rdx
    addl %rsi, %rdi       # rdi -= 1
    rrmovl %rax, %rcx     # rcx = rax
    jne Pow_Loop          # if (rdi != 0) goto Pow_Loop

Pow_End:
    # Clean up stack frame.
    rrmovl %rbp, %rsp
    popl %rbp
    ret

Main:
    brk

    # rax = Pow(3, 4)
    irmovl $3, %rax # base
    irmovl $4, %rbx # exponent
    pushl %rbx
    pushl %rax
    call Pow
    rrmovl %rbp, %rsp

    halt
    